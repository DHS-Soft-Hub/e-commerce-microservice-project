// Auth repository implementation using RTK Query
import { store } from '@/store';
import { IPaginatedResult, IQueryOptions, IResult } from '@dhs-hub/core';
import { SessionEntity } from '../../domain/entities/Session';
import { User, UserEntity } from '../../domain/entities/User';
import { IAuthRepository } from '../../domain/repositories/IAuthRepository';
import {
  AuthResult,
  LoginCredentials,
  RegistrationData
} from '../../domain/types/auth.domain.types';
import { authApi } from '../api/authApi';
import { UserMapper } from '../mappers/UserMapper';
import {
  LoginRequest
} from '../types/api.types';
import { extractErrorMessage } from '../utils';

/**
 * Auth Repository Implementation using RTK Query
 * Implements IAuthRepository interface with actual API calls to FastAPI backend
 */
export class AuthRTKRepository implements IAuthRepository {

  /**
   * Authenticate user with credentials
   * Maps to POST /auth/sign-in endpoint
   */
  async authenticate(credentials: LoginCredentials): Promise<IResult<AuthResult>> {
    try {
      const loginData: LoginRequest = {
        email: credentials.email,
        password: credentials.password,
        totp_code: credentials.totp_code || undefined,
      };

      const result = await store.dispatch(
        authApi.endpoints.login.initiate(loginData)
      );

      if ('error' in result) {
        return {
          isSuccess: false,
          isFailure: true,
          error: new Error(extractErrorMessage(result.error)),
        };
      }

      if (!result.data) {
        return {
          isSuccess: false,
          isFailure: true,
          error: new Error('Authentication failed - no data received'),
        };
      }

      // Transform API response to domain types
      // Note: Login endpoint returns TokenData, need to decode it to get user info
      const token = result.data.access_token;

      // Decode JWT to extract user information
      const userValidationResult = await this.validateToken(token);
      if (!userValidationResult.isSuccess || !userValidationResult.value) {
        return {
          isSuccess: false,
          isFailure: true,
          error: new Error('Failed to decode user information from token' + JSON.stringify(userValidationResult.error))
        };
      }

      const userEntity = userValidationResult.value;
      const session = new SessionEntity(
        '', // ID - will be generated by backend
        '', // Session ID - will be generated by backend  
        userEntity.id, // User ID from token
        { userAgent: '', platform: '' }, // Device info - could be extracted from request
        new Date(), // Created at
        new Date(), // Updated at
        new Date(), // Last activity at
        new Date(Date.now() + 24 * 60 * 60 * 1000), // Expires at - 24 hours
        true // Is active
      );

      const authResult: AuthResult = {
        user: userEntity,
        session,
        accessToken: token,
      };

      return {
        isSuccess: true,
        isFailure: false,
        value: authResult,
      };
    } catch (error) {
      return {
        isSuccess: false,
        isFailure: true,
        error: error as Error,
      };
    }
  }

  /**
   * Register new user
   * Maps to POST /auth/sign-up endpoint
   */
  async register(data: RegistrationData): Promise<IResult<UserEntity>> {
    try {
      const registerData = {
        email: data.email,
        password: data.password,
        first_name: data.firstName,
        last_name: data.lastName,
      };

      const result = await store.dispatch(
        authApi.endpoints.registerBasicUser.initiate(registerData)
      );

      if ('error' in result) {
        return {
          isSuccess: false,
          isFailure: true,
          error: new Error(extractErrorMessage(result.error)),
        };
      }

      if (!result.data) {
        return {
          isSuccess: false,
          isFailure: true,
          error: new Error('Registration failed'),
        };
      }

      // Transform API response to domain types using real backend data
      const user = await store.dispatch(
        authApi.endpoints.getCurrentUser.initiate()
      ).unwrap();

      // Map backend response to UserEntity
      const userEntity = UserMapper.fromApiUserResponse(user);

      return {
        isSuccess: true,
        isFailure: false,
        value: userEntity,
      };
    } catch (error) {
      return {
        isSuccess: false,
        isFailure: true,
        error: error as Error,
      };
    }
  }

  /**
   * Refresh authentication token
   * Maps to POST /auth/token/refresh endpoint
   */
  async refreshToken(_refreshToken: string): Promise<IResult<AuthResult>> {
    try {
      const result = await store.dispatch(
        authApi.endpoints.refreshToken.initiate()
      );

      if ('error' in result) {
        return {
          isSuccess: false,
          isFailure: true,
          error: new Error(extractErrorMessage(result.error)),
        };
      }

      if (!result.data) {
        return {
          isSuccess: false,
          isFailure: true,
          error: new Error('Token refresh failed'),
        };
      }

      // Transform API response to domain types
      // Note: Refresh endpoint returns TokenData, need to decode it to get user info
      const token = result.data.access_token;

      // Decode JWT to extract user information
      const userValidationResult = await this.validateToken(token);
      if (!userValidationResult.isSuccess || !userValidationResult.value) {
        return {
          isSuccess: false,
          isFailure: true,
          error: new Error('Failed to decode user information from refreshed token')
        };
      }

      const userEntity = userValidationResult.value;
      const session = new SessionEntity(
        '', // ID - will be generated by backend
        '', // Session ID - will be generated by backend
        userEntity.id, // User ID from token  
        { userAgent: '', platform: '' }, // Device info
        new Date(), // Created at
        new Date(), // Updated at
        new Date(), // Last activity at
        new Date(Date.now() + 24 * 60 * 60 * 1000), // Expires at - 24 hours
        true // Is active
      );

      const authResult: AuthResult = {
        user: userEntity,
        session,
        accessToken: token,
      };

      return {
        isSuccess: true,
        isFailure: false,
        value: authResult,
      };
    } catch (error) {
      return {
        isSuccess: false,
        isFailure: true,
        error: error as Error,
      };
    }
  }

  /**
   * Revoke authentication token
   * Maps to POST /auth/sign-out endpoint
   */
  async revokeToken(_token: string): Promise<IResult<void>> {
    try {
      const result = await store.dispatch(
        authApi.endpoints.logout.initiate()
      );

      if ('error' in result) {
        return {
          isSuccess: false,
          isFailure: true,
          error: new Error(extractErrorMessage(result.error)),
        };
      }

      return {
        isSuccess: true,
        isFailure: false,
        value: undefined,
      };
    } catch (error) {
      return {
        isSuccess: false,
        isFailure: true,
        error: error as Error,
      };
    }
  }

  /**
   * Validate authentication token
   * Decodes JWT token to extract user information
   */
  async validateToken(token: string): Promise<IResult<UserEntity>> {
    try {
      if (!token || token.trim() === '') {
        return {
          isSuccess: false,
          isFailure: true,
          error: new Error('Token is required'),
        };
      }

      // Basic JWT validation - check if token has proper format
      const tokenParts = token.split('.');
      if (tokenParts.length !== 3) {
        return {
          isSuccess: false,
          isFailure: true,
          error: new Error('Invalid token format'),
        };
      }

      try {
        // Decode the payload (second part of JWT)
        const payload = JSON.parse(atob(tokenParts[1]));

        // Check if token is expired
        const currentTime = Math.floor(Date.now() / 1000);
        if (payload.exp && payload.exp < currentTime) {
          return {
            isSuccess: false,
            isFailure: true,
            error: new Error('Token has expired'),
          };
        }

        // Check if token is issued in the future (basic validation)
        if (payload.iat && payload.iat > currentTime + 60) { // Allow 1 minute clock skew
          return {
            isSuccess: false,
            isFailure: true,
            error: new Error('Token issued in the future'),
          };
        }

        // Check required fields
        if (!payload.user_id) {
          return {
            isSuccess: false,
            isFailure: true,
            error: new Error('Token missing user ID (sub)'),
          };
        }

        // Transform API response to domain types using real backend data
        const user = await store.dispatch(
          authApi.endpoints.getCurrentUser.initiate()
        ).unwrap();

        // Map backend response to UserEntity
        const userEntity = UserMapper.fromApiUserResponse(user);

        return {
          isSuccess: true,
          isFailure: false,
          value: userEntity,
        };
      } catch (_decodeError) {
        return {
          isSuccess: false,
          isFailure: true,
          error: new Error('Failed to decode token payload'),
        };
      }
    } catch (error) {
      return {
        isSuccess: false,
        isFailure: true,
        error: error as Error,
      };
    }
  }

  /**
   * Verify email with token
   * Maps to POST /auth/verify endpoint
   */
  async verifyEmail(token: string): Promise<IResult<void>> {
    try {
      const result = await store.dispatch(
        authApi.endpoints.verifyEmail.initiate({ token })
      );

      if ('error' in result) {
        return {
          isSuccess: false,
          isFailure: true,
          error: new Error(extractErrorMessage(result.error)),
        };
      }

      return {
        isSuccess: true,
        isFailure: false,
        value: undefined,
      };
    } catch (error) {
      return {
        isSuccess: false,
        isFailure: true,
        error: error as Error,
      };
    }
  }

  /**
   * Request password reset
   * Note: This endpoint is not available in the current OpenAPI spec
   */
  async requestPasswordReset(_email: string): Promise<IResult<void>> {
    try {
      // This endpoint is not available in the current API spec
      // This is a placeholder implementation
      console.warn('Password reset endpoint not implemented in current API');

      return {
        isSuccess: false,
        isFailure: true,
        error: new Error('Password reset endpoint not available'),
      };
    } catch (error) {
      return {
        isSuccess: false,
        isFailure: true,
        error: error as Error,
      };
    }
  }

  /**
   * Reset password with token
   * Note: This endpoint is not available in the current OpenAPI spec
   */
  async resetPassword(_token: string, _newPassword: string): Promise<IResult<void>> {
    try {
      // This endpoint is not available in the current API spec
      // This is a placeholder implementation
      console.warn('Reset password endpoint not implemented in current API');

      return {
        isSuccess: false,
        isFailure: true,
        error: new Error('Reset password endpoint not available'),
      };
    } catch (error) {
      return {
        isSuccess: false,
        isFailure: true,
        error: error as Error,
      };
    }
  }

  /**
   * Change password for authenticated user
   * Note: This endpoint is not available in the current OpenAPI spec
   */
  async changePassword(_userId: string, _oldPassword: string, _newPassword: string): Promise<IResult<void>> {
    try {
      // This endpoint is not available in the current API spec
      // This is a placeholder implementation
      console.warn('Change password endpoint not implemented in current API');

      return {
        isSuccess: false,
        isFailure: true,
        error: new Error('Change password endpoint not available'),
      };
    } catch (error) {
      return {
        isSuccess: false,
        isFailure: true,
        error: error as Error,
      };
    }
  }

  /**
   * Check if email exists
   * Note: This endpoint is not available in the current OpenAPI spec
   */
  async emailExists(_email: string): Promise<boolean> {
    try {
      // This endpoint is not available in the current API spec
      // This is a placeholder implementation
      console.warn('Email exists check endpoint not implemented in current API');
      return false;
    } catch (error) {
      console.error('Error checking email existence:', error);
      return false;
    }
  }

  /**
   * Check if username exists
   * Note: This endpoint is not available in the current OpenAPI spec
   */
  async usernameExists(_username: string): Promise<boolean> {
    try {
      // This endpoint is not available in the current API spec
      // This is a placeholder implementation
      console.warn('Username exists check endpoint not implemented in current API');
      return false;
    } catch (error) {
      console.error('Error checking username existence:', error);
      return false;
    }
  }

  /**
   * Get user by email
   * Note: This endpoint is not available in the current OpenAPI spec
   */
  async getUserByEmail(_email: string): Promise<IResult<User>> {
    try {
      // This endpoint is not available in the current API spec
      // This is a placeholder implementation
      console.warn('Get user by email endpoint not implemented in current API');

      return {
        isSuccess: false,
        isFailure: true,
        error: new Error('Get user by email endpoint not available'),
      };
    } catch (error) {
      return {
        isSuccess: false,
        isFailure: true,
        error: error as Error,
      };
    }
  }

  /**
   * Send verification email
   * Maps to POST /auth/resend-code endpoint
   */
  async sendVerificationEmail(email: string): Promise<IResult<void>> {
    try {
      const result = await store.dispatch(
        authApi.endpoints.resendVerification.initiate({ email })
      );

      if ('error' in result) {
        return {
          isSuccess: false,
          isFailure: true,
          error: new Error(extractErrorMessage(result.error)),
        };
      }

      return {
        isSuccess: true,
        isFailure: false,
        value: undefined,
      };
    } catch (error) {
      return {
        isSuccess: false,
        isFailure: true,
        error: error as Error,
      };
    }
  }

  /**
   * Resend verification code
   * Maps to POST /auth/resend-code endpoint
   */
  async resendVerificationCode(email: string): Promise<IResult<void>> {
    try {
      const result = await store.dispatch(
        authApi.endpoints.resendVerification.initiate({ email })
      );

      if ('error' in result) {
        return {
          isSuccess: false,
          isFailure: true,
          error: new Error(extractErrorMessage(result.error)),
        };
      }

      return {
        isSuccess: true,
        isFailure: false,
        value: undefined,
      };
    } catch (error) {
      return {
        isSuccess: false,
        isFailure: true,
        error: error as Error,
      };
    }
  }

  // Additional methods required by IBaseRepository interface
  async findById(id: string): Promise<IResult<UserEntity | null>> {
    const result = await this.validateToken(id);
    if (result.isSuccess) {
      return result;
    }
    return {
      isSuccess: true,
      isFailure: false,
      value: null,
    };
  }

  async findMany(_options?: IQueryOptions): Promise<IResult<UserEntity[]>> {
    return {
      isSuccess: false,
      isFailure: true,
      error: new Error('Find many not applicable for auth repository'),
    };
  }

  async findManyPaginated(_options?: IQueryOptions): Promise<IResult<IPaginatedResult<UserEntity>>> {
    return {
      isSuccess: false,
      isFailure: true,
      error: new Error('Find many paginated not applicable for auth repository'),
    };
  }

  async findFirst(_options?: IQueryOptions): Promise<IResult<UserEntity | null>> {
    return {
      isSuccess: false,
      isFailure: true,
      error: new Error('Find first not applicable for auth repository'),
    };
  }

  async count(_options?: IQueryOptions): Promise<IResult<number>> {
    return {
      isSuccess: false,
      isFailure: true,
      error: new Error('Count not applicable for auth repository'),
    };
  }

  async createMany(_entities: Omit<UserEntity, 'id' | 'createdAt' | 'updatedAt'>[]): Promise<IResult<UserEntity[]>> {
    return {
      isSuccess: false,
      isFailure: true,
      error: new Error('Create many not applicable for auth repository'),
    };
  }

  async updateMany(_options: IQueryOptions, _updates: Partial<UserEntity>): Promise<IResult<number>> {
    return {
      isSuccess: false,
      isFailure: true,
      error: new Error('Update many not applicable for auth repository'),
    };
  }

  async deleteMany(_options?: IQueryOptions): Promise<IResult<number>> {
    return {
      isSuccess: false,
      isFailure: true,
      error: new Error('Delete many not applicable for auth repository'),
    };
  }

  async create(_entity: Omit<UserEntity, 'id' | 'createdAt' | 'updatedAt'>): Promise<IResult<UserEntity>> {
    return {
      isSuccess: false,
      isFailure: true,
      error: new Error('Create not applicable for auth repository - use register method'),
    };
  }

  async update(_id: string, _entity: Partial<UserEntity>): Promise<IResult<UserEntity>> {
    return {
      isSuccess: false,
      isFailure: true,
      error: new Error('Update not applicable for auth repository'),
    };
  }

  async delete(id: string): Promise<IResult<void>> {
    return this.revokeToken(id);
  }

  async exists(id: string): Promise<IResult<boolean>> {
    try {
      const result = await this.validateToken(id);
      return {
        isSuccess: true,
        isFailure: false,
        value: result.isSuccess,
      };
    } catch (error) {
      return {
        isSuccess: false,
        isFailure: true,
        error: error as Error,
      };
    }
  }
}

export default AuthRTKRepository;
